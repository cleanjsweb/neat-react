<!DOCTYPE html><html class="default" lang="en" data-base=".."><head><meta charset="utf-8"/><meta http-equiv="x-ua-compatible" content="IE=edge"/><title>Instance Hook | @cleanweb/react - v2.1.4</title><meta name="description" content="Documentation for @cleanweb/react"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="../assets/style.css"/><link rel="stylesheet" href="../assets/highlight.css"/><script defer src="../assets/main.js"></script><script async src="../assets/icons.js" id="tsd-icons-script"></script><script async src="../assets/search.js" id="tsd-search-script"></script><script async src="../assets/navigation.js" id="tsd-nav-script"></script><script async src="../assets/hierarchy.js" id="tsd-hierarchy-script"></script></head><body><script>document.documentElement.dataset.theme = localStorage.getItem("tsd-theme") || "os";document.body.style.display="none";setTimeout(() => app?app.showPage():document.body.style.removeProperty("display"),500)</script><header class="tsd-page-toolbar"><div class="tsd-toolbar-contents container"><div class="table-cell" id="tsd-search"><div class="field"><label for="tsd-search-field" class="tsd-widget tsd-toolbar-icon search no-caption"><svg width="16" height="16" viewBox="0 0 16 16" fill="none"><use href="../assets/icons.svg#icon-search"></use></svg></label><input type="text" id="tsd-search-field" aria-label="Search"/></div><div class="field"><div id="tsd-toolbar-links"></div></div><ul class="results"><li class="state loading">Preparing search index...</li><li class="state failure">The search index is not available</li></ul><a href="../index.html" class="title">@cleanweb/react - v2.1.4</a></div><div class="table-cell" id="tsd-widgets"><a href="#" class="tsd-widget tsd-toolbar-icon menu no-caption" data-toggle="menu" aria-label="Menu"><svg width="16" height="16" viewBox="0 0 16 16" fill="none"><use href="../assets/icons.svg#icon-menu"></use></svg></a></div></div></header><div class="container container-main"><div class="col-content"><div class="tsd-page-title"><ul class="tsd-breadcrumb"><li><a href="../modules.html">@cleanweb/react</a></li><li><a href="Instance_Hook.html">Instance Hook</a></li></ul></div><div class="tsd-panel tsd-typography"><a id="useinstance" class="tsd-anchor"></a><h2 class="tsd-anchor-link">useInstance<a href="#useinstance" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>With <code>useLogic</code>, most of the issues we identified with function components are addressed. The component is cleaner and the functions are more predictable. But one limitation remains.</p>
<p>The journey of a React component starts as a mere function until it is executed for the first time. The JSX template it returns describes what content should be inserted into the DOM. After this first execution, react generates the corresponding HTML and inserts into the DOM at the appropriate location. At this point we say that the component is &quot;mounted&quot;. After being mounted, a component may go through multiple updates in the course of its journey through life. This happens when either it's internal state changes, or the props from its parent change. When that happens, Reacts executes the function again with this updated input, and receives an equally updated template of what the DOM should now look like based on the new input. React updates the DOM accordingly. This process repeats continously until such time as the parent or some higher ancestor returns an updated template to React that no longer includes the child component in question. At this point, the corresponding DOM element(s) which this component described are removed from the document and we say the component is unmounted.</p>
<p>This is the React component lifecycle. Regardless of the absence or presence or nature of an API to interface with these lifecycle processes, it is a thing that exists, conceptually. It is often very useful to hook into these lifecycle milestones to properly manage the behaviour of a component and guarantee a good user experience. This is why for both class components and function components, React provides ways of performing actions at specified points in the lifecycle of a component.</p>
<p>With class components, these are very obvious because of the declarative API provided. To run some code after the component is mounted, you simply put said code in a method called <code>componentDidMount</code>. It is quite straightforward. Not as much with function components, however. While you can achieve all of the same lifecycle hooks in function component as you could with class components, the API takes a more imperative approach. For example, you cannot simply say that some code should run after the component mounts through some appropriately named function. Instead, you must find the right combination of arguments to pass to <code>useEffect</code> to achieve the desired result. Working with the component lifecyle in a function component carries some extra cognitive load as a result of this.</p>
<p>Say you wanted some code to run <em>before</em> a component is first mounted, for example. In a class component, you would simply put this code in the constructor. This is fairly straightforward to work out given the fact that a class has to first be instantiated, then React calls the relevant instance methods at different times to determine what to render to the DOM. Hence, to run code at the beginning of that process, you do it where the instantiation takes place, i.e the constructor.</p>
<p>With a function component, you may at first glance turn to <code>useEffect</code> and spend some time tinkering with it to see if there is a call signature that would achieve this. It may take some time for you to realize this cannot be done with <code>useEffect</code> at all. Instead, calling <code>useMemo</code> with an empty dependency array should produce the desired effect. This can be very unintuative considering the stated purpose of <code>useMemo</code> and the fact that your &quot;before mount&quot; logic probably doesn't even return a value in the first place, so the thought of using a memoization hook may never have crossed your mind, as there was no value to memoize.</p>
<p>Figuring these things out at the point of writing the component is one thing, but the component also likely has to be maintained long term, and even if you are very familiar with these function component patterns, it may still take you a minute of looking at a long list of hook calls to figure out which lifecycle event a given hook call is really trying to achieve. Which <code>useMemo</code> call is really meant to memoize a value and which is just a hacky workaround to hook into some lifecycle event? What if a single <code>useMemo</code> call achieves both functions, and you mistakenly remove the hook because the value is no longer needed, without realising this side-effect was also being relied on?</p>
<p>You might be attempting to trace the execution path of a component to better understand its behaviour at different points in its lifecycle. Instead of discreet methods for each stage, you might have to track down multiple distinct <code>useEffect</code> calls that all run at the same stage but are written many lines apart in the body of the component function.</p>
<p>The imperative approach for working with lifecycle in function components makes for some very unintuitive components, and at the very least adds a notable cognitive overhead to reading and writing larger components. Creating a declarative mechanism for hooking into the lifecycle of function components without having to simply switch to a class component would be a great improvement. And this is what <code>useInstance</code> achieves. Here is what it looks like:</p>
<pre><code class="jsx"><span class="hl-5">/** Button Component Class. */</span><br/><span class="hl-0">class</span><span class="hl-1"> </span><span class="hl-9">ButtonCC</span><span class="hl-1"> </span><span class="hl-0">extends</span><span class="hl-1"> </span><span class="hl-9">ComponentInstance</span><span class="hl-1"> {</span><br/><span class="hl-1">	</span><span class="hl-5">// ...</span><br/><span class="hl-1">	</span><span class="hl-5">// Static method(s), same as useLogic...</span><br/><span class="hl-1">	</span><span class="hl-5">// ...</span><br/><br/><br/><span class="hl-1">	</span><span class="hl-5">/* Lifecycle Methods */</span><br/><br/><span class="hl-1">	</span><span class="hl-6">beforeMount</span><span class="hl-1"> = () </span><span class="hl-0">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">		</span><span class="hl-5">// Runs before the component is first rendered.</span><br/><span class="hl-1">	}</span><br/><br/><span class="hl-1">	</span><span class="hl-6">onMount</span><span class="hl-1"> = () </span><span class="hl-0">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">		</span><span class="hl-5">// Runs after the component is first rendered.</span><br/><span class="hl-1">		</span><span class="hl-5">// Same as `useEffect(() =&gt; {}, []);`</span><br/><br/><span class="hl-1">		</span><span class="hl-7">return</span><span class="hl-1"> () </span><span class="hl-0">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">			</span><span class="hl-5">// Required clean up function must be returned.</span><br/><span class="hl-1">			</span><span class="hl-5">// Return an empty function if you have no cleanup.</span><br/><span class="hl-1">		};</span><br/><span class="hl-1">	}</span><br/><br/><span class="hl-1">	</span><span class="hl-6">beforeRender</span><span class="hl-1"> = () </span><span class="hl-0">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">		</span><span class="hl-5">// Runs before every single render.</span><br/><span class="hl-1">		</span><span class="hl-5">// Same as code placed before the return statement in a function component.</span><br/><br/><span class="hl-1">		</span><span class="hl-5">// Example: Generate display values from state and props,</span><br/><span class="hl-1">		</span><span class="hl-5">// and store them as instance members for use in your JSX template.</span><br/><span class="hl-1">		</span><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">displayValue2</span><span class="hl-1"> = </span><span class="hl-0">this</span><span class="hl-1">.</span><span class="hl-3">hooks</span><span class="hl-1">.</span><span class="hl-3">memoizedValue</span><span class="hl-1"> + </span><span class="hl-0">this</span><span class="hl-1">.</span><span class="hl-3">state</span><span class="hl-1">.</span><span class="hl-3">value2</span><span class="hl-1">;</span><br/><br/><span class="hl-1">		</span><span class="hl-0">this</span><span class="hl-1">.</span><span class="hl-3">templateContext</span><span class="hl-1"> = {</span><br/><span class="hl-1">			</span><span class="hl-3">intro:</span><span class="hl-1"> </span><span class="hl-4">`Hello, </span><span class="hl-0">${</span><span class="hl-0">this</span><span class="hl-11">.</span><span class="hl-3">props</span><span class="hl-11">.</span><span class="hl-3">name</span><span class="hl-0">}</span><span class="hl-4">`</span><span class="hl-1">,</span><br/><span class="hl-1">			</span><span class="hl-3">displayValue2</span><span class="hl-1">,</span><br/><span class="hl-1">		};</span><br/><span class="hl-1">	}</span><br/><br/><span class="hl-1">	</span><span class="hl-6">onRender</span><span class="hl-1"> = () </span><span class="hl-0">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">		</span><span class="hl-5">// Runs after every single render.</span><br/><span class="hl-1">		</span><span class="hl-5">// Same as `useEffect(() =&gt; {});`</span><br/><br/><span class="hl-1">		</span><span class="hl-7">return</span><span class="hl-1"> () </span><span class="hl-0">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">			</span><span class="hl-5">// Required clean up function must be returned.</span><br/><span class="hl-1">			</span><span class="hl-5">// Return an empty function if you have no cleanup.</span><br/><span class="hl-1">		};</span><br/><span class="hl-1">	}</span><br/><br/><span class="hl-1">	</span><span class="hl-6">cleanUp</span><span class="hl-1"> = () </span><span class="hl-0">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">		</span><span class="hl-5">// Runs when the component is unmounted.</span><br/><span class="hl-1">		</span><span class="hl-5">// Similar to the function returned by `onMount`.</span><br/><span class="hl-1">	}</span><br/><br/><span class="hl-1">	</span><span class="hl-5">/* [End] Lifecycle Methods */</span><br/><br/><br/><span class="hl-1">	</span><span class="hl-5">// ...</span><br/><span class="hl-1">	</span><span class="hl-5">// Other instance methods, same as useLogic...</span><br/><span class="hl-1">	</span><span class="hl-5">// ...</span><br/><span class="hl-1">}</span><br/><br/><span class="hl-5">// Button Template</span><br/><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-6">Button</span><span class="hl-1"> = (</span><span class="hl-3">props</span><span class="hl-1">) </span><span class="hl-0">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">	</span><span class="hl-0">const</span><span class="hl-1"> </span><span class="hl-2">self</span><span class="hl-1"> = </span><span class="hl-6">useInstance</span><span class="hl-1">(</span><span class="hl-3">ButtonCC</span><span class="hl-1">, </span><span class="hl-3">props</span><span class="hl-1">);</span><br/><span class="hl-1">	</span><span class="hl-0">const</span><span class="hl-1"> { </span><span class="hl-2">intro</span><span class="hl-1"> } = </span><span class="hl-3">self</span><span class="hl-1">.</span><span class="hl-3">templateContext</span><span class="hl-1">;</span><br/><br/><span class="hl-1">	</span><span class="hl-7">return</span><span class="hl-1"> </span><span class="hl-8">&lt;&gt;</span><br/><span class="hl-1">		</span><span class="hl-8">&lt;</span><span class="hl-12">p</span><span class="hl-8">&gt;</span><span class="hl-0">{</span><span class="hl-3">intro</span><span class="hl-0">}</span><span class="hl-8">&lt;/</span><span class="hl-12">p</span><span class="hl-8">&gt;</span><br/><span class="hl-1">		</span><span class="hl-8">&lt;</span><span class="hl-12">button</span><span class="hl-1"> </span><span class="hl-10">onClick</span><span class="hl-1">=</span><span class="hl-0">{</span><span class="hl-3">self</span><span class="hl-11">.</span><span class="hl-3">submit</span><span class="hl-0">}</span><span class="hl-8">&gt;</span><br/><span class="hl-1">			</span><span class="hl-0">{</span><span class="hl-3">self</span><span class="hl-11">.</span><span class="hl-3">state</span><span class="hl-11">.</span><span class="hl-3">label</span><span class="hl-0">}</span><br/><span class="hl-1">		</span><span class="hl-8">&lt;/</span><span class="hl-12">button</span><span class="hl-8">&gt;</span><br/><span class="hl-1">	</span><span class="hl-8">&lt;/&gt;</span><span class="hl-1">;</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

<p>See the <a href="https://cleanjsweb.github.io/neat-react/classes/API.BaseClasses.ComponentInstance.html">API documentation</a> for each lifecycle method to learn more about how it works.</p>
<p>With the addition of the lifecycle methods, the component logic class starts to look very much like a <code>React.Component</code> component class. It can now be thought of as a complete representation of the behaviours associated with a given component template. Each instance of this class fully represents an instance of the function component in the DOM—state,
props, and all—hence the name. <code>useInstance</code> allows your function component to consume a logical instance of itself, and operate simply as a template that transforms a self contained object with state and behaviours into a DOM subtree with UI and event listeners.</p>
<p>At this point, you might jokingly say, &quot;we've basically recreated class components&quot;. We pretty much have, with one significant advantage. At its core, your component is still a function component, and can seamlessly benefit from any optimizations, improvements, or new features that React adds to function components. Its the best of both worlds. Stay on the new system, and carry over all of the advantages from the old one. The declarative lifecycle API, the ergonomics of working with state, and the cleaner structure and separation of concerns. <code>useInstance</code> gives you all of this in a neat and simple package.</p>
<p>Now, if we're going to work our way back to writing components as classes, why not just go all the way?
Well, actually, <a href="https://cleanjsweb.github.io/neat-react/documents/Class_Component.html">we can</a>.</p>
</div></div><div class="col-sidebar"><div class="page-menu"><div class="tsd-navigation settings"><details class="tsd-accordion"><summary class="tsd-accordion-summary"><h3><svg width="20" height="20" viewBox="0 0 24 24" fill="none"><use href="../assets/icons.svg#icon-chevronDown"></use></svg>Settings</h3></summary><div class="tsd-accordion-details"><div class="tsd-filter-visibility"><span class="settings-label">Member Visibility</span><ul id="tsd-filter-options"><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-protected" name="protected"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Protected</span></label></li><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-inherited" name="inherited" checked/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Inherited</span></label></li><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-external" name="external"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>External</span></label></li></ul></div><div class="tsd-theme-toggle"><label class="settings-label" for="tsd-theme">Theme</label><select id="tsd-theme"><option value="os">OS</option><option value="light">Light</option><option value="dark">Dark</option></select></div></div></details></div><details open class="tsd-accordion tsd-page-navigation"><summary class="tsd-accordion-summary"><h3><svg width="20" height="20" viewBox="0 0 24 24" fill="none"><use href="../assets/icons.svg#icon-chevronDown"></use></svg>On This Page</h3></summary><div class="tsd-accordion-details"><a href="#useinstance"><span>use<wbr/>Instance</span></a></div></details></div><div class="site-menu"><nav class="tsd-navigation"><a href="../modules.html">@cleanweb/react - v2.1.4</a><ul class="tsd-small-nested-navigation" id="tsd-nav-container"><li>Loading...</li></ul></nav></div></div></div><footer><p class="tsd-generator">Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p></footer><div class="overlay"></div></body></html>
