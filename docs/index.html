<!DOCTYPE html><html class="default" lang="en" data-base="."><head><meta charset="utf-8"/><meta http-equiv="x-ua-compatible" content="IE=edge"/><title>@cleanweb/react</title><meta name="description" content="Documentation for @cleanweb/react"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="assets/style.css"/><link rel="stylesheet" href="assets/highlight.css"/><script defer src="assets/main.js"></script><script async src="assets/icons.js" id="tsd-icons-script"></script><script async src="assets/search.js" id="tsd-search-script"></script><script async src="assets/navigation.js" id="tsd-nav-script"></script><script async src="assets/hierarchy.js" id="tsd-hierarchy-script"></script></head><body><script>document.documentElement.dataset.theme = localStorage.getItem("tsd-theme") || "os";document.body.style.display="none";setTimeout(() => app?app.showPage():document.body.style.removeProperty("display"),500)</script><header class="tsd-page-toolbar"><div class="tsd-toolbar-contents container"><div class="table-cell" id="tsd-search"><div class="field"><label for="tsd-search-field" class="tsd-widget tsd-toolbar-icon search no-caption"><svg width="16" height="16" viewBox="0 0 16 16" fill="none"><use href="assets/icons.svg#icon-search"></use></svg></label><input type="text" id="tsd-search-field" aria-label="Search"/></div><div class="field"><div id="tsd-toolbar-links"></div></div><ul class="results"><li class="state loading">Preparing search index...</li><li class="state failure">The search index is not available</li></ul><a href="index.html" class="title">@cleanweb/react</a></div><div class="table-cell" id="tsd-widgets"><a href="#" class="tsd-widget tsd-toolbar-icon menu no-caption" data-toggle="menu" aria-label="Menu"><svg width="16" height="16" viewBox="0 0 16 16" fill="none"><use href="assets/icons.svg#icon-menu"></use></svg></a></div></div></header><div class="container container-main"><div class="col-content"><div class="tsd-page-title"><h1>@cleanweb/react</h1></div><div class="tsd-panel tsd-typography"><a id="object-oriented-programming-for-react" class="tsd-anchor"></a><h1 class="tsd-anchor-link">Object Oriented Programming for React<a href="#object-oriented-programming-for-react" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h1><p>This package provides a number of tools for creating React function components with object-oriented code. With Oore, you can avoid common errors, and write complex components that are cleaner, better structured, and eassier to read &amp; understand.</p>
<p>Oore is written in Typescript and all exports are fully typed.</p>
<a id="usage" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Usage<a href="#usage" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h2><a id="clean-state" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Clean State<a href="#clean-state" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>The <code>useCleanState</code> hook provides a clean API for working with multiple state variables in a unified way. The example below demonstrates how to use it.</p>
<pre><code class="jsx">const initialState = {
	label: 'Click me',
	clicked: false,
	inputValue: {},
};
// or
const getInitialState = (props) => {
	return {
		label: props.label,
		clicked: false,
		inputValue: {},
	};
};

const Button = (props) => {
	const state = useCleanState(initialState);
	// or
	const state = useCleanState(getInitialState, props);
	

	const onClick = useCallback(() => {
		state.clicked = true;
		// or
		state.putMany({
			label: 'Loading',
			clicked: true,
		});
		// or
		state.put.clicked(true);
		// or
		state.put.clicked((oldClicked) => !oldClicked);
	}, []);

	return <>
		<CustomInput setValue={state.put.inputValue}>

		<button onClick={onClick}>
			{state.label}
		</button>
	</>;
}
</code><button type="button">Copy</button></pre>

<blockquote>
<p><strong>Note:</strong> You can call <code>useCleanState</code> multiple times in the same component, allowing you to group related state values into separate objects.</p>
</blockquote>
<blockquote>
<p><strong>Note:</strong> Each top-level key in your initial state object gets a separate call to <code>React.useState</code>, and <code>state.put[key]()</code> is a proxy for the setter function returned from <code>useState</code>. So using this hook is fundamentally the same as calling <code>useState</code> directly for each value. What <code>useCleanState</code> provides is a way to unify those values and a convenient API for updating them.</p>
</blockquote>
<p><a href="">Read the <code>useCleanState</code> docs</a> for more details.</p>
<a id="methods" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Methods<a href="#methods" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>The <code>useMethods</code> hook lets you manage the closures that your component uses in a separate class, keeping the body of the component clean and easier to read. With <code>useMethods</code>, your functions are not recreated on every render. Yet, every method of your component is guaranteed to always have access to the latest props and state without the need for a dependencty array.</p>
<pre><code class="jsx">class ButtonMethods {
	submit = () => {
		const { state1, state2 } = this.state;
		sendData(state1, state2);
		this.state.submitted = true;
	}

	doSomething = () => {
		console.table(this.props);
	} 
}

const initialState = {
	value1: undefined,
	value2: null,
	label: 'Click me',
	submitted: false,
}

const Button = (props) => {
	const state = useCleanState(initialState);
	const methods = useMethods(ButtonMethods, state, props);

	useEffect(methods.doSomething, []);

	return (
		<button onClick={methods.submit}>
			{state.label}
		</button>
	);
}
</code><button type="button">Copy</button></pre>

<p><code>useMethods</code> only accepts a single state object. So if you are using multiple calls to <code>useCleanState</code>, you may have to group them into a single object when calling <code>useMethods</code>.</p>
<pre><code class="jsx">const getDefaultValues = (props) => ({/* ... */});

const Button = (props) => {
	const formValues = useCleanState(getDefaultValues, props);
	const apiData = useCleanState({});

	const multiState = { formValues, apiData };
	const methods = useMethods(ButtonMethods, multiState, props);

	// ...
}
</code><button type="button">Copy</button></pre>

<p><a href="">Read the <code>useMethods</code> docs</a> for more details.</p>
<a id="logic" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Logic<a href="#logic" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>The <code>useLogic</code> hook is an expansion of <code>useMethods</code>, with the aim of being a more holistic solution. It combines the functionality of <code>useCleanState</code> and <code>useMethods</code>. In addition, it allows you to externalize <em>all</em> of your component's logic, not just closures and state. Essentially, this means being able to call hooks from within the class, rather than having to do so within the component body.</p>
<pre><code class="jsx">class ButtonLogic {
	static getInitialState = () => {
		return {
			value1: undefined,
			value2: null,
			label: 'Click me',
			submitted: false,
		};
	}

	submit = async () => {
		const { value1, value2 } = this.state;
		await sendData(value1, value2);
		this.state.submitted = true;
	}

	doSomething = () => {
		// ...
	}

	useHooks = () => {
		const { param } = this.props;

		useEffect(this.doSomething, []);

		const memoizedValue = useMemo(() => getValue(param), [param]);
		const value2 = useCustomHook();

		return {
			memoizedValue,
			value2,
		};
	}
}

// Button Template
const Button = (props) => {
	const { state, hooks, ...methods } = useLogic(ButtonLogic, props);

	return <>
		<p>{hooks.memoizedValue}</p>
		<button onClick={methods.submit}>
			{state.label}
		</button>
	</>;
}
</code><button type="button">Copy</button></pre>

<p><a href="">Read the <code>useLogic</code> docs</a> for more details.</p>
<a id="lifecycle-useinstance" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Lifecycle (<code>useInstance</code>)<a href="#lifecycle-useinstance" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>The <code>useInstance</code> hook provides a simple approach for working with your components lifecycle. It includes all the features of <a href="#logic"><code>useLogic</code></a>, and adds special lifecycle methods. This gives you a declarative way to run certain code at specific stages of your component's life time. You will likely find this to be less error prone and much easier to reason about than the imperative approach of using React's hooks directly.</p>
<pre><code class="jsx">/** Button Component Class. */
class ButtonCC extends ComponentInstance {
	// ...
	// Static method(s), same as useLogic...
	// ...


	/* Lifecycle Methods */

	beforeMount = () => {
		// Runs before the component is first rendered.
		// This is implemented using useMemo.
	}

	onMount = () => {
		// Runs after the component is first rendered.
		// Same as `useEffect(() => {}, []);`

		return () => {
			// Required clean up function must be returned.
			// Return an empty function if you have no cleanup.
		};
	}

	beforeRender = () => {
		// Runs before every single render.
		// Same as code placed before the return statement in a function component.

		// Example: Generate display values from state and props,
		// and return them for use in your JSX template.
		const displayValue2 = this.hooks.memoizedValue + this.state.value2;

		// The optional returned object will be available
		// on the created instance as `instance.templateContext`
		return {
			intro: `Hello, ${this.props.name}`,
			displayValue2,
		};

		// PS: For any expensive logic, you should wrap it
		// in useMemo and move it into the useHooks method instead.
	}

	onRender = () => {
		// Runs after every single render.
		// Same as `useEffect(() => {});`

		return () => {
			// Required clean up function must be returned.
			// Return an empty function if you have no cleanup.
		};
	}

	cleanUp = () => {
		// Runs when the component is unmounted.
		// Similar to the function returned by `onMount`.
	}

	/* [End] Lifecycle Methods */


	// ...
	// Other instance methods, same as useLogic...
	// ...
}

// Button Template
const Button = (props) => {
	const self = useInstance(ButtonCC, props);
	const ctx = self.templateContext;

	return <>
		<p>{ctx.intro}</p>
		<button onClick={self.submit}>
			{self.state.label}
		</button>
	</>;
}
</code><button type="button">Copy</button></pre>

<p><a href="">Read the <code>useInstance</code> docs</a> for more details.</p>
<a id="class-component" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Class Component<a href="#class-component" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>With <code>useInstance</code>, pretty much every aspect of your component is now part of the class, except for the JSX template. The <code>ClassComponent</code> class takes that final step and provides a fully integrated class-based React component.</p>
<p>If you're currently maintaining older components written with the old <code>React.Component</code> class and you would like to rewrite them as function components with hooks, porting them to <code>ClassComponent</code> will <em>significantly</em> simplify and speed up the migration process. You can access all the latest React features, without changing the overall structure of your existing component classes.</p>
<pre><code class="jsx">class Button extends ClassComponent {
	/** See the description of the `RC` property below this example. */
	static RC = Button.extract();
	// Or...
	static RC = Button.FC();
	// Or, using `this`, which refers to the class itself
	// when the static keyword is present...
	static RC = this.extract();
	// Or...
	static RC = this.FC();

	// ...
	// Other static and instance members, same as useInstance...
	// ...


	beforeRender = () => {
		const displayValue2 = this.hooks.memoizedValue + this.state.value2;

		return {
			intro: `Hello, ${this.props.name}`,
			displayValue2,
		};
	}

	/**
	 * Button Template.
	 * @param ctx - The `templateContext` object returned in `beforeRender`.
	 * Will be `undefined` if nothing is returned by `beforeRender`.
	 */
	template = (ctx) => (
		<section>
			<p>{ctx.intro}</p>

			<button onClick={this.submit}>
				{this.state.label}
			</button>
		</section>
	);
}

export default Button.RC;
// Or render directly with `<Button.RC />`.
</code><button type="button">Copy</button></pre>

<p>Every class derived from the base <code>ClassComponent</code> is not itself a React component. Instead, it has a static <code>extract()</code> method (also aliased as <code>FC()</code> for &quot;Function Component&quot;) which returns a function component that can be rendered like any other React component. Each instance of this function component mounted in the React tree creates it's own separate instance of your <code>ClassComponent</code> class. To make it easier to use the class component directly, you should create a static property that holds the function component returned by <code>extract</code>. The recommended convention is to use the name <code>RC</code> (for &quot;React Component&quot;). Such a class can then easily be rendered as JSX by writing <code>&lt;MyComponent.RC /&gt;</code>.</p>
<p><a href="">Read the <code>ClassComponent</code> docs</a> for more details.</p>
<a id="other-exports" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Other Exports<a href="#other-exports" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><a id="the--component" class="tsd-anchor"></a><h4 class="tsd-anchor-link">The <code>&lt;Use&gt;</code> Component<a href="#the--component" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h4><p>If you simply want to use hooks in your <code>React.Component</code> class without having to rewrite anything, this package also exports a <code>&lt;Use&gt;</code> component that helps you achieve this easily. Here's how to use it.</p>
<pre><code class="jsx">import { useGlobalStore } from '@/hooks/store';

class Button extends React.Component {
	syncGlobalStore = ([store, updateStore]) => {
		if (this.state.userId !== store.userId) {
			this.setState({ userId: store.userId });
		}
		this.store = store;
		this.updateStore = updateStore;
	}

	UseHooks = () => {
		return <>
			<Use hook={useGlobalStore}
				onUpdate={syncGlobalStore}
				argumentsList={[]}
				key="useGlobalStore"
			/>
		</>;
	}

	render() {
		const { UseHooks } = this;

		return <>
			<UseHooks />

			<button>Click me</button>
		</>;
	}
}
</code><button type="button">Copy</button></pre>

<p>The provided hook is called with the <code>argumentsList</code> array passed in (the array is spread, so each item in the list is a separate argument). The return value from the hook is passed on to the <code>onUpdate</code> callback. So you can use this to update your component's state and trigger a rerender when something changes.</p>
<a id="merged-state" class="tsd-anchor"></a><h4 class="tsd-anchor-link">Merged State<a href="#merged-state" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h4><p>This package also exports a <code>useMergedState</code> hook, which provides all the same features as <code>useCleanState</code>, but with a slightly different implementation.</p>
<p>The <code>useCleanState</code> hook is designed to exactly mirror how function components are usually written: a separate <code>React.useState</code> call for each distinct value. <code>useMergedState</code> takes a simpler approach by making just one <code>React.useState</code> call for the entire <code>initialState</code> object. Functionally though, the effect is probably the same.</p>
<p>It is recommended that you use <code>useCleanState</code> instead of this since that implementation is truer to how <code>React.useState</code> is commonly used. <code>useMergedState</code> may be removed in future versions.</p>
<a id="issues" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Issues<a href="#issues" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>If you observe an issue or bug, please report it by creating an issue on the <a href="">Oore repo on GitHub</a>.</p>
<a id="known-issues" class="tsd-anchor"></a><h4 class="tsd-anchor-link">Known Issues<a href="#known-issues" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h4><p>Methods on your component classes may not be updated as expected during HMR. So fully refreshing the page may sometimes be required while developing with Oore. A fix for this is being investigated.</p>
</div></div><div class="col-sidebar"><div class="page-menu"><div class="tsd-navigation settings"><details class="tsd-accordion"><summary class="tsd-accordion-summary"><h3><svg width="20" height="20" viewBox="0 0 24 24" fill="none"><use href="assets/icons.svg#icon-chevronDown"></use></svg>Settings</h3></summary><div class="tsd-accordion-details"><div class="tsd-filter-visibility"><span class="settings-label">Member Visibility</span><ul id="tsd-filter-options"><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-protected" name="protected"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Protected</span></label></li><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-inherited" name="inherited" checked/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Inherited</span></label></li><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-external" name="external"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>External</span></label></li></ul></div><div class="tsd-theme-toggle"><label class="settings-label" for="tsd-theme">Theme</label><select id="tsd-theme"><option value="os">OS</option><option value="light">Light</option><option value="dark">Dark</option></select></div></div></details></div><details open class="tsd-accordion tsd-page-navigation"><summary class="tsd-accordion-summary"><h3><svg width="20" height="20" viewBox="0 0 24 24" fill="none"><use href="assets/icons.svg#icon-chevronDown"></use></svg>On This Page</h3></summary><div class="tsd-accordion-details"><a href="#object-oriented-programming-for-react"><span>Object <wbr/>Oriented <wbr/>Programming for <wbr/>React</span></a><ul><li><a href="#usage"><span>Usage</span></a></li><li><ul><li><a href="#clean-state"><span>Clean <wbr/>State</span></a></li><li><a href="#methods"><span>Methods</span></a></li><li><a href="#logic"><span>Logic</span></a></li><li><a href="#lifecycle-useinstance"><span>Lifecycle (use<wbr/>Instance)</span></a></li><li><a href="#class-component"><span>Class <wbr/>Component</span></a></li><li><a href="#other-exports"><span>Other <wbr/>Exports</span></a></li><li><ul><li><a href="#the--component"><span>The &lt;<wbr/>Use&gt; <wbr/>Component</span></a></li><li><a href="#merged-state"><span>Merged <wbr/>State</span></a></li></ul></li><li><a href="#issues"><span>Issues</span></a></li><li><ul><li><a href="#known-issues"><span>Known <wbr/>Issues</span></a></li></ul></li></ul></li></ul></div></details></div><div class="site-menu"><nav class="tsd-navigation"><a href="modules.html">@cleanweb/react</a><ul class="tsd-small-nested-navigation" id="tsd-nav-container"><li>Loading...</li></ul></nav></div></div></div><footer><p class="tsd-generator">Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p></footer><div class="overlay"></div></body></html>
